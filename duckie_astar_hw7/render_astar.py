#!/usr/bin/env python


"""
This script applies A* to plan paths to randomly sampled goals using the previously rendered costmap.

If you have not already, complete the script render_costmap.py
A* is a graph search algorithm that enables the optimal path to be found between two points that mimizes cost.
We control the cost by assigning positive weights to the graph edges.
These weights are calculated using the costmap generated by render_costmap.py
In this script you will be using an implementation of A* using the networkx library.

test your implementation with the following command:
python duckie_astar_hw7/render_astar.py --infile "costmap.png" --outfile "plan.png"

This script renders to the screen, which you need to record and include in your checkoff submission.
"""


import argparse
import cv2
import numpy as np
import networkx
from gym_duckietown.envs import DuckietownEnv


def astar(start, end, costmap):
    def distance(node1, node2):
        return np.sqrt(np.square(node1[0] - node2[0]) + np.square(
            node1[1] - node2[1]))
    graph = networkx.grid_2d_graph(costmap.shape[1], costmap.shape[0])
    for node1, node2, edge in graph.edges(data=True):
        edge['weight'] = 999999 * (1.0 - costmap[node1[1], node1[0]])
        edge['weight'] = 999999 * (1.0 - costmap[node2[1], node2[0]])
    return networkx.astar_path(
        graph, (start[0], start[1]), (end[0], end[1]), distance)


if __name__ == "__main__":

    parser = argparse.ArgumentParser()
    parser.add_argument('--env-name', default=None)
    parser.add_argument('--map-name', default='udem1')
    parser.add_argument('--distortion', default=False, action='store_true')
    parser.add_argument('--draw-curve', action='store_true', help='draw the lane following curve')
    parser.add_argument('--draw-bbox', action='store_true', help='draw collision detection bounding boxes')
    parser.add_argument('--domain-rand', action='store_true', help='enable domain randomization')
    parser.add_argument('--frame-skip', default=1, type=int, help='number of frames to skip')
    parser.add_argument('--seed', default=1, type=int, help='seed')
    parser.add_argument('--transform', default="transform.npy", type=str)
    parser.add_argument('--infile', default="costmap.png", type=str)
    parser.add_argument('--outfile', default="plan.png", type=str)
    args = parser.parse_args()

    env = DuckietownEnv(
        seed=args.seed,
        map_name=args.map_name,
        draw_curve=args.draw_curve,
        draw_bbox=args.draw_bbox,
        domain_rand=args.domain_rand,
        frame_skip=args.frame_skip,
        distortion=args.distortion,
        do_color_relabeling=False)

    env.reset()
    env.render(mode="top_down")

    transform = np.load(args.transform)
    car_pos = (env.cur_pos[::2] / transform[0] + transform[1:])
    car_pos = (int(car_pos[0]), int(car_pos[1]))
    car_angle = env.cur_angle

    costmap = cv2.imread(args.infile, cv2.IMREAD_UNCHANGED).astype(float) / 255.0

    height = costmap.shape[0]
    width = costmap.shape[1]
    coords = np.stack(np.meshgrid(np.arange(width), np.arange(height)), axis=2)

    """BEGIN YOUR CODE"""

    # randomly sample a position for the car to navigate to in image coordinates.

    # call the function astar using teh starting position of the car in image coordinates
    # the goal you sampled, and also the costmap

    # assign the result to the variable trajectory

    # render the trajectory visibly superimposed on a rendered image of the duckietown sim
    # save this result to args.outfile

    """END YOUR CODE"""

    input("wrote plan to {}, press enter to continue...".format(args.outfile))

    current_goal = trajectory.pop(0)
    while len(trajectory) > 0:

        car_position = (env.cur_pos[::2] / transform[0] + transform[1:])
        car_angle = env.cur_angle

        while car_angle < 0:
            car_angle += 2 * np.pi

        while car_angle > 2 * np.pi:
            car_angle -= 2 * np.pi

        direction_of_goal = np.array(current_goal) - car_position
        distance_to_goal = np.linalg.norm(direction_of_goal, ord=2)

        if distance_to_goal < 35:
            current_goal = trajectory.pop(0)
            continue

        angle_to_goal = np.arctan2(-direction_of_goal[1], direction_of_goal[0])
        angle_to_goal = angle_to_goal if angle_to_goal > 0 else 2 * np.pi + angle_to_goal

        while angle_to_goal < 0:
            angle_to_goal += 2 * np.pi

        while angle_to_goal > 2 * np.pi:
            angle_to_goal -= 2 * np.pi

        angle_offset = angle_to_goal - car_angle

        """BEGIN YOUR CODE"""

        # using your PID controller from the previous homework
        # devise a control scheme for enabling the duckie bot car to follow the "current_goal"

        # assign this result to the variable action

        """END YOUR CODE"""

        env.step(action)

        env.render(mode="top_down")
